
Analisi Passo-Passo dell'esecuzione di MSP sul Grafo

Il seguente tracciamento descrive le operazioni logiche eseguite dalla funzione "msp" e dal main del programma, applicate al grafo di test:

1. Fase di Pre-elaborazione (Nel main)

Prima di analizzare i singoli path, il programma esegue una volta sola il calcolo della Matrice mp_matrix.
Questa matrice indica se due nodi sono collegati da diversi cammini.

-Viene allocata una matrice.
-Doppio Ciclo: Il programma itera su ogni coppia di nodi .
-Test hasmultp(i, j)`: Per ogni coppia, la funzione conta quanti cammini distinti esistono da un nodo ad un altro nodo.
-Se il numero di cammini è >=2 , imposta mp_matrix[i][j] = 1.
-Altrimenti, lascia 0.


2. Funzione MSP:

Il programma ora analizza ogni path singolarmente. Prendiamo in esame il Path 2 (Verde) che contiene il "Salto Estremo".

Dati in Input alla funzione:

-pi: Array del percorso 
-pi_lenght: 11 (lunghezza del path)
-mp_matrix: La matrice calcolata al punto 1.

Inizializzazione Variabili:

-max_edges: Calcola il numero massimo teorico di archi ().
-S: Alloca memoria per salvare gli archi risultanti.
-s_index: Inizializzato a 0 (contatore archi trovati).
-pre: Viene impostato sull'ultimo nodo del path.
-pre = pi[10] = 20 (Il nodo finale).




-ciclo for (int j = pi_lenght - 2; j >= 0; j--) 
-scorre il path dal penultimo nodo fino al primo.
-Iterazione 1: Nodo Corrente curr = 19
-Controllo Matrice: mp_matrix[19][20] == 1? 
-Risultato: False. mp_matrix[19][20]=1 perchè non esistono più cammini tra il nodo 19 e 20, ma solo un arco diretto.

-Iterazione 1: curr=19
 mp_matrix[19][20]=1?
 No, non esistono piu cammini dal nodo 19 al nodo 20, ma solo un arco diretto.

-Iterazione 2: curr = 12
 Controllo Matrice: mp_matrix[12][20] == 1?
 No, non esistono più cammini dal nodo 12 al nodo 20.

-Iterazione 3: curr=11
 mp_matrix[11][20]=1?
  Si, esistono due diversi cammini che portano dal nodo 11 al nodo 20
  Viene salvato l'arco in S
  S[0]=11
  S[1]=12
  pre=11


-Iterazione 4: nodi 10, 9
  -vengono confrontati i nodi 10, 9 con pre=11.
  -Controllo Matrice: mp_matrix[curr][12] == 1?
  -Risultato: falso per tutti.



 -Iterazione 5:curr = 6
 -mp_matrix[6][12] == 1?
 -Risultato: falso.


 -Iterazione 6: Nodi 5, 3
 -Controllo Matrice: falso.


 -Iterazione 7: Nodo Corrente curr = 2
 -Controllo Matrice: mp_matrix[2][12] == 1?
 -Risultato: vero.
 -viene salvato l'arco in S
 -S[2] = 2
 -S[3] = 3 (il nodo successivo nel path, pi[j+1])
 -pre=2




-Iterazione 10: Nodo Corrente curr = 1
 -Controllo Matrice: FALSO.



-Inversione dell'Array :
Alla fine del ciclo, l'array S contiene gli archi trovati in ordine inverso.
Il codice esegue un ciclo di swap per riordinarli correttamente.
La funzione restituisce il puntatore all'array S e scrive in `num_edges` il numero totale di archi trovati (2).



